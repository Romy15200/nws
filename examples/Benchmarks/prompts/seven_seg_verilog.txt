**Task:**  
You are an expert in formal hardware verification. Your task is to analyze a SystemVerilog hardware module and a hard-to-verify property. Then, suggest intermediate lemmas that could simplify the verification process in Jasper by breaking down the complex property into smaller, verifiable parts.

**Instructions:**

1. **Understand the Module:** Analyze the provided SystemVerilog module to grasp its functionality, focusing on relevant state transitions, signal interactions, and critical behaviors.
2. **Analyze the Hard Property:** Break down the given property into smaller logical components. Identify why it might be hard for Jasper to verify (e.g., complex dependencies, wide state space, non-trivial data paths).
3. **Identify Invariants and Behaviors:** Think about invariants or simple behaviors that must always hold true and could serve as intermediate lemmas.
4. **Generate Lemmas:** Propose lemmas that are easier to prove and, when assumed, help Jasper verify the hard property.
5. **Explain the Reasoning:** For each lemma, explain why it is relevant and how it simplifies the verification.

For example, for the following verilog module:
module PWM_TOP (input clk, input [3:0] sw, output reg pulse_red);

  localparam CBITS = 21;    // Change pulse_wideR accordingly

  wire [CBITS-1:0] pulse_wideR;
  assign pulse_wideR = {1'b0, sw[3:1], 17'd0};     // (CBTIS-4)

  reg [CBITS-1:0] cnt_R;

  always @(posedge clk) begin
    cnt_R <= cnt_R + 1;

    if (cnt_R < pulse_wideR)
      pulse_red = 1'b1;
    else
      pulse_red = 1'b0;

  end

p1: assert property  (@(posedge clk) (always s_eventually pulse_red == 0)) ; 
endmodule

You may want to propose the following lemmas:
1. assume property (@(posedge clk) (pulse_wideR < 2**20));
2. assume property (@(posedge clk) (always s_eventually cnt_R == 2**20));
**Your Turn:**  
Analyze the provided module and property. Provide formal lemmas in SystemVerilog Assertion format that can assist in verifying the hard property of the given module.


module SEVEN(input clk, input rst, input [13:0] both7seg, output reg[6:0] segment);
	localparam freq = 160000;
	localparam CBITS = 18;

	reg [CBITS-1:0] cnt;
	reg digit_select;

	always @(posedge clk) begin
		if(rst == 1) begin
			cnt = 0;
			digit_select = 0;
			segment = 0;
		end
		if(cnt < freq)
			cnt = cnt + 1;
		else begin
			cnt = 0;
			if(digit_select == 0) begin
				digit_select = 1;
				segment = both7seg[13:7];
			end
			else begin
				digit_select = 0;
				segment = both7seg[6:0];
			end
		end
	end
	p2: assert property (@(posedge clk) (always s_eventually rst == 1) or (always s_eventually (digit_select == 0 and (always s_eventually digit_select == 1)))) ;
	//F G (rst = FALSE) -> G F (digit_select = FALSE & G F (digit_select = TRUE))
endmodule